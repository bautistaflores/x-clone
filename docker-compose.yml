services:
  frontend: # Servicio para el frontend
    build:
      context: ./client
      dockerfile: Dockerfile
    container_name: x-clone-client
    volumes:
      - ./client:/app
      - /app/node_modules
    environment:
      - NODE_ENV=development
      - CHOKIDAR_USEPOLLING=true 
      - WDS_SOCKET_PORT=0
    command: npm run dev
    networks:
      - app-network
    depends_on:
      - auth-service
      - posts-service
      - notifications-service

  auth-service: # Servicio para el microservicio de usuarios y autenticación
    build: 
      context: ./services/auth-service
      dockerfile: Dockerfile
      target: development
    entrypoint: /app/entrypoint-dev.sh
    container_name: auth-service
    # ports: No es necesario exponer el puerto 4000 al host si se accede vía Nginx
    depends_on:
      postgres:
          condition: service_healthy
      redis:
          condition: service_healthy
    env_file:
      - ./services/auth-service/.env
    environment:
      - NODE_ENV=development
      - CHOKIDAR_USEPOLLING=true
    volumes:
      - ./services/auth-service:/app
      - ./config/entrypoint-dev.sh:/app/entrypoint-dev.sh:ro
      - /app/node_modules
    networks:
      - app-network

  posts-service:
    build: 
      context: ./services/posts-service
      dockerfile: Dockerfile
      target: development
    entrypoint: /app/entrypoint-dev.sh
    container_name: posts-service
    # ports: No es necesario exponer el puerto 5000 al host si se accede vía Nginx
    depends_on:
      postgres:
        condition: service_healthy
    env_file:
      - ./services/posts-service/.env
    environment:
      - NODE_ENV=development
      - CHOKIDAR_USEPOLLING=true
    volumes:
      - ./services/posts-service:/app
      - ./config/entrypoint-dev.sh:/app/entrypoint-dev.sh:ro
      - /app/node_modules
    networks:
      - app-network

  notifications-service:
    build: 
      context: ./services/notifications-service
      dockerfile: Dockerfile
      target: development
    entrypoint: /app/entrypoint-dev.sh
    container_name: notifications-service
    # ports: No es necesario exponer el puerto 6000 al host si se accede vía Nginx
    depends_on:
      postgres:
          condition: service_healthy
      redis:
          condition: service_healthy
    env_file:
      - ./services/notifications-service/.env
    environment:
      - NODE_ENV=development
      - CHOKIDAR_USEPOLLING=true
    volumes:
      - ./services/notifications-service:/app
      - ./config/entrypoint-dev.sh:/app/entrypoint-dev.sh:ro
      - /app/node_modules
    networks:
      - app-network

  postgres:
    image: postgres:15
    container_name: postgres
    restart: always
    env_file: 
      - ./config/db.env
    volumes:
      - pgdata:/var/lib/postgresql/data
      - ./config/init-multiple-dbs.sh:/docker-entrypoint-initdb.d/init-multiple-dbs.sh
    ports:
      - "5432:5432"
    networks:
      - app-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER:-postgres} -d $${POSTGRES_DB:-postgres}"]
      interval: 5s
      timeout: 5s
      retries: 10

  redis:
    image: redis:alpine
    container_name: redis
    ports: 
      - "6379:6379"
    volumes:
      - redisdata:/data
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 5s
      retries: 10

  nginx:
    image: nginx:alpine
    container_name: nginx-gateway
    ports:
      - "80:80" # Nginx escucha en el puerto 80 del host
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro # :ro para solo lectura
      - ./services/auth-service/public/profile_pictures:/app/services/auth-service/public/profile_pictures
      - ./services/posts-service/public/imagePosts:/app/services/posts-service/public/imagePosts
    depends_on:
      - frontend
      - auth-service
      - posts-service
      - notifications-service
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

volumes:
  pgdata:
  redisdata: